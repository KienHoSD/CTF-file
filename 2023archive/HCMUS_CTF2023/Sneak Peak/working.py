# I'm not the one who solved this. I'm borrow the solution :P
from Crypto.Util.number import long_to_bytes as ltb, bytes_to_long as btl, inverse
from attacks.factorization.coppersmith import factorize_p
from shared.partial_integer import PartialInteger
n = 137695652953436635868173236797773337408441001182675256086214756367750388214098882698624844625677992374523583895607386174643756159168603070583418054134776836804709359451133350283742854338177917816199855370966725059377660312824879861277400624102267119229693994595857701696025366109135127015217981691938713787569
leak = 6745414226866166172286907691060333580739794735754141517928503510445368134531623057
ct = 60939585660386801273264345336943282595466297131309357817378708003135300231065734017829038358019271553508356563122851120615655640023951268162873980957560729424913748657116293860815453225453706274388027182906741605930908510329721874004000783548599414462355143868922204060850666210978837231187722295496753756990
p,q =factorize_p(
    n, # modulus 
    PartialInteger.parse_be(f"{leak:0272b}" + '?'*240, 2), # f(x) = (leak * 2^240) + x
    0.5, # beta for solving equation on f(x) mod n^beta
    0.03  # decrease this for higher shift => Bigger lattice dimension => Take more computation power but more accuracy
)
# print(p,q)
d=inverse(65537, (p-1)*(q-1))
print(ltb(pow(ct, d, n)).decode())

